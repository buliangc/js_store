http1.0 最主要的特点是短连接，建立TCP连接，发送数据，断开TCP连接
http1.1的首部开销会比HTTP1.0要大一点，但传输速度更快。

http1.1 最主要的特点是长连接  即在一个TCP连接上，发送多个HTTP请求。谷歌浏览器会限制并发请求数量6个，即可建立6个TCP连接
原先的12个请求，因为六个通道，如果某一个通道堵塞了，后面的资源就会处于等待状态，整体加载时间因为这个特性变长了。
1. 域名切片技术：将12个资源请求放到三个域名下面，因为每个域名都可以有6个连接，所以最多有18个连接。但队头堵塞问题仍然存在。
2. 通过webpack将小的js合并为大的js，以此来减少请求次数
3. 通过雪碧图的方式将小的ICON进行合并
4. 或者使用内联来把图片卸载样式中减少请求数量
[缺点明显] 
1. 打破原本缓存的优势，原先只需要更新很小的js文件，现在却需要更新一个较大的js文件。
2. 我们每个请求都在重复发送User Agent, Cookie等各种相同字段，并且因为请求没有状态，我们需要使用Cookie或者自定义的authorization请求头来告诉服务端当前用户的认证信息。

[改革]
在HTTP1.1中，请求头信息肯定是文本，请求体可以是文本也可以是二进制(binary);
[http2.0]
http2.0是一个彻头彻尾的二进制协议，请求头和请求体都是二进制，并且统称为帧(frame)，头信息帧和数据帧
http2.0 最主要的是二进制分帧层 多路复用(只有一个TCP连接) 首部压缩()

# 队头堵塞问题：
HTTP1.1 的队头堵塞问题
比如 HTTP/1.1 时代建立一个 TCP 连接，三个请求组成一个队列发出去，服务器接收到这个队列之后会依次响应，一旦前面的请求阻塞，后面的请求就会无法响应。


HTTP/2 是通过分帧并且给每个帧打上流的 ID 去避免依次响应的问题，对方接收到帧之后根据 ID 拼接出流，这样就可以做到乱序响应从而避免请求时的队首阻塞问题
并且Http2.0支持服务端推送，在还未请求资源的时候，先把资源发送过去。


http1.1
- keep-alive使得http请求可以复用TCP连接，从而降低建立连接的耗时（2次round trip）
- 队头阻塞问题限制并发性能（通过减少请求或域名切片优化）
- 无状态，多次请求可能需要重复发送cookie用来维护会话，导致请求体积增大影响性能

http2
- 解决体积问题：
  - 使用binary传输数据（哈夫曼编码）
  - 使用HPack压缩格式，压缩请求和响应标头元数据
  - 连接中维护headers的静态表和动态表，缺省的标头字段使用静态表的值（因此，可以说http2是有状态的协议）
- 解决队头阻塞
  - 分帧的多路复用（二进制是分帧的前提，分帧是多路复用的前提，http2的多路复用并非时分或频分复用，服务端组装请求时通根据每一帧的前9个字节进行组装，详细原理见这盘文章：https://segmentfault.com/a/1190000016975064）
- push
  - 服务端可以主动推送静态资源给客户端，前置下载流程，客户端缓存静态资源，当解析到该资源时，直接读缓存而非单独发送请求

http3
- TCP协议的队头阻塞
  - 使用基于UDP协议的QUIC协议和TLS1.3协议，RTT从6降低到1，解决TCP队头阻塞问题，进一步优化性能