正则表达式的两种方法
1. 匹配：验证字符串是不是符合正则规则
=> 语法： 正则.test(你要检测的字符串)
=> 返回值：一个布尔值，true或者false

2. 捕获: 从字符串里面获取符合正则规则的那一部分片段
=> 语法： 正则.exec(你要捕获的字符串)
=> 返回值
exec
\t  匹配 制表符(tab)
\s  匹配一个空白字符，包括空格、制表符、换页符和换行符
\S  匹配 非空白字符
\d  匹配 数字
\D  匹配 非数字
\w  匹配 (数字 字母 下划线)
\W  匹配 非(数字 字母 下划线)
(.) 匹配 非换行
\ 斜线: 转义符 

## 边界元字符
1. ^：字符串开始
2. $: 字符串结束

## 限定元字符 写在普通元字符或者字母符号的后面
/**
 *  1. * 表示你的字符串里面需要出现一个0~多个数字组成的片段
 *  2. + 表示你的字符串只能由1~多个组成
 *  3. ？表示你的字符串只能由0 或者 1 个组成
 *  4. {n} 表示出现n次  
 *  5. {n,} 表示出现n~多个组成
        {0，} 相当于*
        {1，} 相当于+
 *  6. {n, m} 表示出现n~m 个组成
 */

## 正则的贪婪性和非贪婪性

/** 
 *  贪婪性：
 *  + 当给你一个符号使用限定符的时候
 *  + 在你捕获的时候，他会尽可能多的去捕获内容
 *  + 我们管这个特性叫做正则的贪婪性
 *  
 *  非贪婪性 限定符？
 *  + 正则在捕获的时候尽可能的按照最小值来进行捕获
 *  + 写限定符的时候，在后面多加一个?
 */

## 特殊字符
/**
 * 1.()
 * 表示一个整体
 * 从左到右一次数小括号的开始括号
 * 2.(?:)
 * 整体匹配但不捕获
 * 只是标志一个整体，但是捕获的时候不会单独捕获出来
 * 3.| 占位或
 * 表示左边或者右边都行
 * 大部分的时候用()连用，表示一个整体或者一个整体
 * 注意：或分开的是左边和右边的整个
 * 4. [] 中括号
 * 注意：**一个[]占一个字符的位置
 * 表示括号中的字符串只要有一个即可
 * 5.[^]
 * 注意：一个[^]占一个字符位置
 * 表示非里面的任意一个都可以
 * 6. - 
 * 表示 至 或者 到的意思
 * 是使用在[]里面的一个符号
 */

## 正则表达式的预查
    正向预查 
        正向肯定预查
        正向否定预查
    负向预查
        负向肯定预查
        负向否定预查
    
## 重复出现
\num 表示的是正则第num个可被捕获的() 这个可被不会的小括号的位置是什么 出现 一模一样的内容
/(?:[abcd])\d+([abcd])\d+\1/  ?:整体匹配但不捕获

## 标识符
i : 忽略大小写
g : 全局搜索
y ：粘性全局

## 字符串和正则合作的方法
search() 