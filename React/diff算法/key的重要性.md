一般diff在比较集合[A,B,C,D]和[B，A，D，C]的时候会进行全部对比，即按对应位置逐个比较，发现每个位置对应的元素都有所更新，则把旧集合全部移除，替换成新的集合，如上图，但是这样的操作在React中显然是复杂、低效、影响性能的操作，因为新集合中所有的元素都可以进行[复用]，无需删除重新创建，耗费性能和内存，只需要移动元素位置即可。   

React对这一现象做出了一个高效的策略：[允许开发者对同一层级的同组子节点添加唯一key值进行区分]。意义就是代码上的一小步，性能上的一大步，甚至是翻天覆地的变化！

[重点来了，React通过key是如何进行element管理的呢？为何如此高效？]
算法改进：  

React会先进行新集合遍历，for(name in nextChildren)，通过key值判断两个对比集合中是否存在相同的节点，即if(prevChild === nextChild)，如何为true则进行移动操作，在此之前，需要执行被移动节点在新旧（child._mountIndex）集合中的位置比较，if(child._mountIndex < lastIndex)为true时进行移动，否则不执行该操作，这实际上是一种顺序优化，lastIndex是不断更新的，表示访问过的节点在集合中的最右的位置。若当前访问节点在旧集合中的位置比lastIndex大，即靠右，说明它不会影响其他元素的位置，因此不用添加到差异队列中，不执行移动操作，反之则进行移动操作。