
# this指向的四个绑定规则 
1. 默认绑定
2. 隐式绑定
3. 显示绑定 
4. new 构造函数绑定


# 函数的四种调用方式
1. 独立调用 this 指向window     对应默认绑定
IIFE，[闭包]的执行方式也相当于独立调用，this指向window
闭包：当函数执行的时候，导致函数被定义，并抛出。(闭包就是在一个作用域中可以使用另一个作用域的变量)

2. 方法调用 this 指向调用者      对应隐式绑定 但会出现 [隐式丢失] 的情况，
隐式丢失 比如 变量赋值 和 参数赋值（将实参赋值给形参） 
```javascript
[第一种变量赋值]
function foo() {
    console.log(this);
}
var obj = {
    a: 2,
    foo: foo
}

var bar = obj.foo;      （出现隐式丢失 变量直接赋值）
bar();  //  这里就相当于独立调用

[第二种参数赋值]
var a = 0;
function foo() {
    console.log(this);
}

function bar(fn) {  // 这里将实参赋值给形参
    fn();       // 这里就相当于独立调用
}

var obj = {
    a: 2,
    foo:foo
}
bar(obj.foo)
```
3. 间接调用 apply call bind 
4. 构造函数调用 this 指向构造函数
对于构造函数，this指向可以通过return返回值进行更改，但一般情况下不会修改构造函数的this指向，直接使用new，构造出一个新的实例，实例的隐式属性指向当前的构造函数的原型
构造函数使用 this 关键字定义变量和方法，当 this 遇到 return 的时候，会发生指向不明（调用结果不明）的问题：

return 返回的不是一个对象，this 还是指向实例（新对象），调用结果也还是新对象；
return 返回的是 null，this 还是指向实例，调用结果也还是新对象；
return 返回的是一个对象，this 就指向这个返回的对象，调用结果就是这个返回的对象；

# 箭头函数的this指向问题 箭头函数内部是没有this指向的，箭头函数内部不存在arguments对象

1. 默认绑定规则 (独立调用对箭头函数) 无效
2. 隐式绑定规则 (对象调用对箭头函数) 无效
当时疑惑的点在于箭头函数 隐式绑定的this，在对象中进行调用，那会找对象作为外层的this吗？
显然不会，因为作用域问题，只分为函数作用域 全局作用域 块级作用域（对象的大括号不属于，别弄混了） 
```javascript 隐式绑定规则 无效
    var obj1 = {
        a:1,
        foo: () => {
            console.log(this);
        }
    }
    obj1.foo(); // 对象调用 也是 隐式绑定 输出window
```
3. 显示绑定规则 (间接调用对箭头函数) 无效
4. 箭头函数不支持作为构造函数使用

[总结] 
## 箭头函数：所有绑定规则全部不适用，箭头函数的this取决于父环境中的this
